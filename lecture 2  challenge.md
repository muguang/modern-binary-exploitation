## crackme0x00a
```
➜  challenges ./crackme0x00a
Enter password: AAAAA
Wrong!
Enter password: 
```

使用ltrace很方便
```
➜  challenges ltrace ./crackme0x00a 
__libc_start_main(0x80484e4, 1, 0xbfac4674, 0x8048570 <unfinished ...>
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x8048651, 0xbfac45b3, 0x8049ff4, 0x8048591Enter password: AAAAAAAA
)                  = 1
strcmp("g00dJ0B!", "AAAAAAAA")                                               = 1
puts("Wrong!"Wrong!
)                                                               = 7
printf("Enter password: ")                
```
或者使用 安装gef插件的gdb
```
0xbffff28c│+0x00: 0x0804852f  →  test eax, eax	 ← $esp
0xbffff290│+0x04: 0x0804a024  →  "g00dJ0B!"
0xbffff294│+0x08: 0xbffff2a3  →  "AAAAAAAA"
0xbffff298│+0x0c: 0x08049ff4  →  0x08049f28  →  0x1
0xbffff29c│+0x10: 0x08048591  →  lea eax, [ebx-0xe0]
0xbffff2a0│+0x14: 0x41000001
0xbffff2a4│+0x18: "AAAAAAA"
0xbffff2a8│+0x1c: 0x00414141 ("AAA"?)
```

或者使用gdb 进行查看
```
gef➤  x/12x $esp
0xbffff28c:	0x2f	0x85	0x04	0x08	0x24	0xa0	0x04	0x08
0xbffff294:	0xa3	0xf2	0xff	0xbf
gef➤  x/12c 0x0804a024
0x804a024 <pass.1685>:	103 'g'	48 '0'	48 '0'	100 'd'	74 'J'	48 '0'	66 'B'	33 '!'
0x804a02c <pass.1685+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'
gef➤  x/12c 0xbffff2a3
0xbffff2a3:	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'
0xbffff2ab:	0 '\000'	43 '+'	122 'z'	-30 '\342'
```

---
## crackme0x00b

在这里使用 ltrace 就不行了
```
➜  challenges ltrace ./crackme0x00b   
__libc_start_main(0x8048494, 1, 0xbfacda54, 0x8048500 <unfinished ...>
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x80485e1, 0xbfacd94c, 0xc30000, 0Enter password: AAAAAAAA
)                           = 1
wcscmp(0x804a040, 0xbfacd94c, 0xc30000, 0)                                   = 1
puts("Wrong!"Wrong!
)                                                               = 7
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x80485e1, 0xbfacd94c, 0xc30000, 0Enter password: 
```
*objdump 用查看信息，发现是使用wcscmp 进行比较的*
```
➜  challenges objdump -T crackme0x00b  

crackme0x00b:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000      DF *UND*	00000000  GLIBC_2.0   printf
00000000      DF *UND*	00000000  GLIBC_2.0   **wcscmp**
00000000      DF *UND*	00000000  GLIBC_2.0   puts
00000000  w   D  *UND*	00000000              __gmon_start__
00000000      DF *UND*	00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*	00000000  GLIBC_2.7   __isoc99_scanf
080485cc g    DO .rodata	00000004  Base        _IO_stdin_used

```
查看 wcscmp 的定义
>
> NAME
>       wcscmp - compare two wide-character strings
>
>SYNOPSIS
>       #include <wchar.h>
>
>       int wcscmp(const wchar_t *s1, const wchar_t *s2);
>
>DESCRIPTION
>       The wcscmp() function is the wide-character equivalent of the strcmp(3)
>       function.  It compares the wide-character string pointed to by  s1  and
>       the wide-character string pointed to by s2.
>
是使用字符串指针进行比较的，

使用gdb 进入调试
```
gef➤  x/12xw $esp
0xbffff23c:	0x080484d3	**0x0804a040**	0xbffff25c	0x00c30000
0xbffff24c:	0x00000000	0xb7fff000	0xb7fff918	0xbffff270
0xbffff25c:	0x00000041	0x00000041	0x00000041	0x00000041
```
**0x0804a040** 是字符串首地址，直接查看 **0x0804a040**处的字符串
```
gef➤  x/12cw 0x0804a040
0x804a040 <pass.1964>:	119 'w'	48 '0'	119 'w'	103 'g'
0x804a050 <pass.1964+16>:	114 'r'	101 'e'	97 'a'	116 't'
0x804a060 <pass.1964+32>:	0 '\000'	0 '\000'	0 '\000'	0 '\000' 
```
```
➜  challenges ./crackme0x00b 
Enter password: w0wgreat
Congrats!
```

























