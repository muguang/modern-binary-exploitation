## crackme0x00a
```
➜  challenges ./crackme0x00a
Enter password: AAAAA
Wrong!
Enter password: 
```

使用ltrace很方便
```
➜  challenges ltrace ./crackme0x00a 
__libc_start_main(0x80484e4, 1, 0xbfac4674, 0x8048570 <unfinished ...>
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x8048651, 0xbfac45b3, 0x8049ff4, 0x8048591Enter password: AAAAAAAA
)                  = 1
strcmp("g00dJ0B!", "AAAAAAAA")                                               = 1
puts("Wrong!"Wrong!
)                                                               = 7
printf("Enter password: ")                
```
或者使用 安装gef插件的gdb
```
0xbffff28c│+0x00: 0x0804852f  →  test eax, eax	 ← $esp
0xbffff290│+0x04: 0x0804a024  →  "g00dJ0B!"
0xbffff294│+0x08: 0xbffff2a3  →  "AAAAAAAA"
0xbffff298│+0x0c: 0x08049ff4  →  0x08049f28  →  0x1
0xbffff29c│+0x10: 0x08048591  →  lea eax, [ebx-0xe0]
0xbffff2a0│+0x14: 0x41000001
0xbffff2a4│+0x18: "AAAAAAA"
0xbffff2a8│+0x1c: 0x00414141 ("AAA"?)
```

或者使用gdb 进行查看
```
gef➤  x/12x $esp
0xbffff28c:	0x2f	0x85	0x04	0x08	0x24	0xa0	0x04	0x08
0xbffff294:	0xa3	0xf2	0xff	0xbf
gef➤  x/12c 0x0804a024
0x804a024 <pass.1685>:	103 'g'	48 '0'	48 '0'	100 'd'	74 'J'	48 '0'	66 'B'	33 '!'
0x804a02c <pass.1685+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'
gef➤  x/12c 0xbffff2a3
0xbffff2a3:	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'
0xbffff2ab:	0 '\000'	43 '+'	122 'z'	-30 '\342'
```

---
## crackme0x00b

在这里使用 ltrace 就不行了
```
➜  challenges ltrace ./crackme0x00b   
__libc_start_main(0x8048494, 1, 0xbfacda54, 0x8048500 <unfinished ...>
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x80485e1, 0xbfacd94c, 0xc30000, 0Enter password: AAAAAAAA
)                           = 1
wcscmp(0x804a040, 0xbfacd94c, 0xc30000, 0)                                   = 1
puts("Wrong!"Wrong!
)                                                               = 7
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x80485e1, 0xbfacd94c, 0xc30000, 0Enter password: 
```
**objdump 用查看信息，发现是使用wcscmp 进行比较的**
```
➜  challenges objdump -T crackme0x00b  

crackme0x00b:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000      DF *UND*	00000000  GLIBC_2.0   printf
00000000      DF *UND*	00000000  GLIBC_2.0   **wcscmp**
00000000      DF *UND*	00000000  GLIBC_2.0   puts
00000000  w   D  *UND*	00000000              __gmon_start__
00000000      DF *UND*	00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*	00000000  GLIBC_2.7   __isoc99_scanf
080485cc g    DO .rodata	00000004  Base        _IO_stdin_used

```
查看 wcscmp 的定义
>
> NAME
>       wcscmp - compare two wide-character strings
>
>SYNOPSIS
>       #include <wchar.h>
>
>       int wcscmp(const wchar_t *s1, const wchar_t *s2);
>
>DESCRIPTION
>       The wcscmp() function is the wide-character equivalent of the strcmp(3)
>       function.  It compares the wide-character string pointed to by  s1  and
>       the wide-character string pointed to by s2.
>
是使用字符串指针进行比较的，

使用gdb 进入调试
```
gef➤  x/12xw $esp
0xbffff23c:	0x080484d3	**0x0804a040**	0xbffff25c	0x00c30000
0xbffff24c:	0x00000000	0xb7fff000	0xb7fff918	0xbffff270
0xbffff25c:	0x00000041	0x00000041	0x00000041	0x00000041
```
**0x0804a040** 是字符串首地址，直接查看 **0x0804a040**处的字符串
```
gef➤  x/12cw 0x0804a040
0x804a040 <pass.1964>:	119 'w'	48 '0'	119 'w'	103 'g'
0x804a050 <pass.1964+16>:	114 'r'	101 'e'	97 'a'	116 't'
0x804a060 <pass.1964+32>:	0 '\000'	0 '\000'	0 '\000'	0 '\000' 
```
```
➜  challenges ./crackme0x00b 
Enter password: w0wgreat
Congrats!
```

---
## crackme0x01
```
➜  challenges ./crackme0x01
IOLI Crackme Level 0x01
Password: AAAAAA
Invalid Password!
```

ltrace failed.
```
➜  challenges ltrace ./crackme0x01       
__libc_start_main(0x80483e4, 1, 0xbfcdfae4, 0x8048460 <unfinished ...>
printf("IOLI Crackme Level 0x01\n"IOLI Crackme Level 0x01
)                                                    = 24
printf("Password: ")                                                                   = 10
scanf(0x804854c, 0xbfcdfa44, 0, 0xb7535a2bPassword: AAAAAAAA
)                                            = 0
printf("Invalid Password!\n"Invalid Password!
)                                                          = 18
+++ exited (status 0) +++
```

使用 gdb进行调试

```
gef➤  disassemble 
Dump of assembler code for function main:
   0x080483e4 <+0>:	push   ebp
   0x080483e5 <+1>:	mov    ebp,esp
   0x080483e7 <+3>:	sub    esp,0x18
=> 0x080483ea <+6>:	and    esp,0xfffffff0
   0x080483ed <+9>:	mov    eax,0x0
   ... 
   ...
   0x08048426 <+66>:	call   0x804830c <scanf@plt>
   0x0804842b <+71>:	**cmp    DWORD PTR [ebp-0x4],0x149a**
   0x08048432 <+78>:	je     0x8048442 <main+94>
   0x08048434 <+80>:	mov    DWORD PTR [esp],0x804854f
   0x0804843b <+87>:	call   0x804831c <printf@plt>
   0x08048440 <+92>:	jmp    0x804844e <main+106>
   0x08048442 <+94>:	mov    DWORD PTR [esp],0x8048562
   0x08048449 <+101>:	call   0x804831c <printf@plt>
   0x0804844e <+106>:	mov    eax,0x0
   0x08048453 <+111>:	leave  
   0x08048454 <+112>:	ret    
End of assembler dump.

```
可以看到** cmp    DWORD PTR [ebp-0x4],0x149a**这一条指令是进行比较操作的

```
>>> 0x149a
5274
```

```
➜  challenges ./crackme0x01
IOLI Crackme Level 0x01
Password: 5274
Password OK :)
```
OK

























