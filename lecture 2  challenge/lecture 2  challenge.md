## crackme0x00a
```
➜  challenges ./crackme0x00a
Enter password: AAAAA
Wrong!
Enter password: 
```

使用ltrace很方便
```
➜  challenges ltrace ./crackme0x00a 
__libc_start_main(0x80484e4, 1, 0xbfac4674, 0x8048570 <unfinished ...>
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x8048651, 0xbfac45b3, 0x8049ff4, 0x8048591Enter password: AAAAAAAA
)                  = 1
strcmp("g00dJ0B!", "AAAAAAAA")                                               = 1
puts("Wrong!"Wrong!
)                                                               = 7
printf("Enter password: ")                
```
或者使用 安装gef插件的gdb
```
0xbffff28c│+0x00: 0x0804852f  →  test eax, eax	 ← $esp
0xbffff290│+0x04: 0x0804a024  →  "g00dJ0B!"
0xbffff294│+0x08: 0xbffff2a3  →  "AAAAAAAA"
0xbffff298│+0x0c: 0x08049ff4  →  0x08049f28  →  0x1
0xbffff29c│+0x10: 0x08048591  →  lea eax, [ebx-0xe0]
0xbffff2a0│+0x14: 0x41000001
0xbffff2a4│+0x18: "AAAAAAA"
0xbffff2a8│+0x1c: 0x00414141 ("AAA"?)
```

或者使用gdb 进行查看
```
gef➤  x/12x $esp
0xbffff28c:	0x2f	0x85	0x04	0x08	0x24	0xa0	0x04	0x08
0xbffff294:	0xa3	0xf2	0xff	0xbf
gef➤  x/12c 0x0804a024
0x804a024 <pass.1685>:	103 'g'	48 '0'	48 '0'	100 'd'	74 'J'	48 '0'	66 'B'	33 '!'
0x804a02c <pass.1685+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'
gef➤  x/12c 0xbffff2a3
0xbffff2a3:	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'	65 'A'
0xbffff2ab:	0 '\000'	43 '+'	122 'z'	-30 '\342'
```

---
## crackme0x00b

在这里使用 ltrace 就不行了
```
➜  challenges ltrace ./crackme0x00b   
__libc_start_main(0x8048494, 1, 0xbfacda54, 0x8048500 <unfinished ...>
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x80485e1, 0xbfacd94c, 0xc30000, 0Enter password: AAAAAAAA
)                           = 1
wcscmp(0x804a040, 0xbfacd94c, 0xc30000, 0)                                   = 1
puts("Wrong!"Wrong!
)                                                               = 7
printf("Enter password: ")                                                   = 16
__isoc99_scanf(0x80485e1, 0xbfacd94c, 0xc30000, 0Enter password: 
```
**objdump 用查看信息，发现是使用wcscmp 进行比较的**
```
➜  challenges objdump -T crackme0x00b  

crackme0x00b:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000      DF *UND*	00000000  GLIBC_2.0   printf
00000000      DF *UND*	00000000  GLIBC_2.0   **wcscmp**
00000000      DF *UND*	00000000  GLIBC_2.0   puts
00000000  w   D  *UND*	00000000              __gmon_start__
00000000      DF *UND*	00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*	00000000  GLIBC_2.7   __isoc99_scanf
080485cc g    DO .rodata	00000004  Base        _IO_stdin_used

```
查看 wcscmp 的定义
>
> NAME
>       wcscmp - compare two wide-character strings
>
>SYNOPSIS
>       #include <wchar.h>
>
>       int wcscmp(const wchar_t *s1, const wchar_t *s2);
>
>DESCRIPTION
>       The wcscmp() function is the wide-character equivalent of the strcmp(3)
>       function.  It compares the wide-character string pointed to by  s1  and
>       the wide-character string pointed to by s2.
>
是使用字符串指针进行比较的，

使用gdb 进入调试
```
gef➤  x/12xw $esp
0xbffff23c:	0x080484d3	**0x0804a040**	0xbffff25c	0x00c30000
0xbffff24c:	0x00000000	0xb7fff000	0xb7fff918	0xbffff270
0xbffff25c:	0x00000041	0x00000041	0x00000041	0x00000041
```
**0x0804a040** 是字符串首地址，直接查看 **0x0804a040**处的字符串
```
gef➤  x/12cw 0x0804a040
0x804a040 <pass.1964>:	119 'w'	48 '0'	119 'w'	103 'g'
0x804a050 <pass.1964+16>:	114 'r'	101 'e'	97 'a'	116 't'
0x804a060 <pass.1964+32>:	0 '\000'	0 '\000'	0 '\000'	0 '\000' 
```
```
➜  challenges ./crackme0x00b 
Enter password: w0wgreat
Congrats!
```

---
## crackme0x01
```
➜  challenges ./crackme0x01
IOLI Crackme Level 0x01
Password: AAAAAA
Invalid Password!
```

ltrace failed.
```
➜  challenges ltrace ./crackme0x01       
__libc_start_main(0x80483e4, 1, 0xbfcdfae4, 0x8048460 <unfinished ...>
printf("IOLI Crackme Level 0x01\n"IOLI Crackme Level 0x01
)                                                    = 24
printf("Password: ")                                                                   = 10
scanf(0x804854c, 0xbfcdfa44, 0, 0xb7535a2bPassword: AAAAAAAA
)                                            = 0
printf("Invalid Password!\n"Invalid Password!
)                                                          = 18
+++ exited (status 0) +++
```

使用 gdb进行调试

```
gef➤  disassemble 
Dump of assembler code for function main:
   0x080483e4 <+0>:	push   ebp
   0x080483e5 <+1>:	mov    ebp,esp
   0x080483e7 <+3>:	sub    esp,0x18
=> 0x080483ea <+6>:	and    esp,0xfffffff0
   0x080483ed <+9>:	mov    eax,0x0
   ... 
   ...
   0x08048426 <+66>:	call   0x804830c <scanf@plt>
   0x0804842b <+71>:	**cmp    DWORD PTR [ebp-0x4],0x149a**
   0x08048432 <+78>:	je     0x8048442 <main+94>
   0x08048434 <+80>:	mov    DWORD PTR [esp],0x804854f
   0x0804843b <+87>:	call   0x804831c <printf@plt>
   0x08048440 <+92>:	jmp    0x804844e <main+106>
   0x08048442 <+94>:	mov    DWORD PTR [esp],0x8048562
   0x08048449 <+101>:	call   0x804831c <printf@plt>
   0x0804844e <+106>:	mov    eax,0x0
   0x08048453 <+111>:	leave  
   0x08048454 <+112>:	ret    
End of assembler dump.

```
可以看到** cmp    DWORD PTR [ebp-0x4],0x149a**这一条指令是进行比较操作的

```
>>> 0x149a
5274
```

```
➜  challenges ./crackme0x01
IOLI Crackme Level 0x01
Password: 5274
Password OK :)
```

---
## crackme0x02


gdb 反汇编，查看scanf到cmp之间的逻辑
```
   0x08048426 <+66>:	call   0x804830c <scanf@plt>
   0x0804842b <+71>:	mov    DWORD PTR [ebp-0x8],0x5a
   0x08048432 <+78>:	mov    DWORD PTR [ebp-0xc],0x1ec
   0x08048439 <+85>:	mov    edx,DWORD PTR [ebp-0xc]
   0x0804843c <+88>:	lea    eax,[ebp-0x8]
   0x0804843f <+91>:	add    DWORD PTR [eax],edx
   0x08048441 <+93>:	mov    eax,DWORD PTR [ebp-0x8]
   0x08048444 <+96>:	imul   eax,DWORD PTR [ebp-0x8]
   0x08048448 <+100>:	mov    DWORD PTR [ebp-0xc],eax
   0x0804844b <+103>:	mov    eax,DWORD PTR [ebp-0x4]
   0x0804844e <+106>:	cmp    eax,DWORD PTR [ebp-0xc]
```

ebp-0x4 作为scanf函数调用的参数，就是我们的输入值
最后的cmp 就是 [ebp-0x4] 和   (0x5a+0x1ec)*(0x5a+0x1ec)

```
In [3]: (0x5a+0x1ec)**2
Out[3]: 338724
```

```
➜  challenges ./crackme0x02 
IOLI Crackme Level 0x02
Password: 338724
Password OK :)
```

---
## crackme0x03

```
   0x080484da <+66>:	call   0x8048330 <scanf@plt>
   0x080484df <+71>:	mov    DWORD PTR [ebp-0x8],0x5a
   0x080484e6 <+78>:	mov    DWORD PTR [ebp-0xc],0x1ec
   0x080484ed <+85>:	mov    edx,DWORD PTR [ebp-0xc]
   0x080484f0 <+88>:	lea    eax,[ebp-0x8]
   0x080484f3 <+91>:	add    DWORD PTR [eax],edx
   0x080484f5 <+93>:	mov    eax,DWORD PTR [ebp-0x8]
   0x080484f8 <+96>:	imul   eax,DWORD PTR [ebp-0x8]
   0x080484fc <+100>:	mov    DWORD PTR [ebp-0xc],eax
   0x080484ff <+103>:	mov    eax,DWORD PTR [ebp-0xc]
   0x08048502 <+106>:	mov    DWORD PTR [esp+0x4],eax
   0x08048506 <+110>:	mov    eax,DWORD PTR [ebp-0x4]
   0x08048509 <+113>:	mov    DWORD PTR [esp],eax
   0x0804850c <+116>:	call   0x804846e <test>

```

查看test函数的反汇编
```
gef➤  disassemble 0x804846e
Dump of assembler code for function test:
   0x0804846e <+0>:	push   ebp
   0x0804846f <+1>:	mov    ebp,esp
   0x08048471 <+3>:	sub    esp,0x8
   0x08048474 <+6>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048477 <+9>:	cmp    eax,DWORD PTR [ebp+0xc]
   0x0804847a <+12>:	je     0x804848a <test+28>
   0x0804847c <+14>:	mov    DWORD PTR [esp],0x80485ec
   0x08048483 <+21>:	call   0x8048414 <shift>
   0x08048488 <+26>:	jmp    0x8048496 <test+40>
   0x0804848a <+28>:	mov    DWORD PTR [esp],0x80485fe
   0x08048491 <+35>:	call   0x8048414 <shift>
   0x08048496 <+40>:	leave  
   0x08048497 <+41>:	ret    
End of assembler dump.
```
**cmp    eax,DWORD PTR [ebp+0xc]**

```
gef➤  x/x $ebp+0xc
0xbffff2a4:	0x00052b24

In [2]: 0x00052b24
Out[2]: 338724
```

```
➜  challenges ./crackme0x03
IOLI Crackme Level 0x03
Password: 338724    
Password OK!!! :)
```

---
## crackme0x04

<check>
```
   0x0804849e <+26>:	call   0x8048384 <strlen@plt>
   0x080484a3 <+31>:	cmp    DWORD PTR [ebp-0xc],eax
```

使用radare2的图形化输出功能 

![IMAGE](resources/0596CB7A7C94BDD0B8365EAFB854E6B0.jpg =882x508)

其中 cmp 操作  对 [ebp-0x8]和 0xf进行比较
对 [ebp-0x8]在动态调试下进行观察，结果为：［ebp-0x8]是对输入的值进行取模求和，然后进行比较， 所以答案不唯一
0x080484d6    <check+82>     cmp   DWORD PTR [ebp-0x8],0xf 

```
➜  challenges ./crackme0x04
IOLI Crackme Level 0x04
Password: 1111111111111111
Password OK!

➜  challenges ./crackme0x04
IOLI Crackme Level 0x04
Password: 55555
Password OK!

➜  challenges ./crackme0x04
IOLI Crackme Level 0x04
Password: 33333
Password OK!
```

使用radamsa 进行fuzzing，很方便
```
➜  challenges sh demo.sh 
Password: Password OK!
Found

➜  challenges echo |cat input_case| ./crackme0x04
IOLI Crackme Level 0x04
Password: Password OK!

```
demo.sh:
```
while true
do 
	 echo "1" |radamsa > input_case
	 cat input_case| ./crackme0x04  |grep "OK"
	 if [ $? -eq 0 ];
	 then 
		echo "Found"
		break
	 else
		 echo "Finding"	 
		 sleep 1
		 clear
	 fi
done

```
---
## crackme 0x05 

用上面的模糊测试脚本成功跑出了一个答案，不过还是gdb调试看一下内部逻辑


main

 0x08048590 <+80>:	call   0x80484c8 <check>


check

   0x08048518 <+80>:	add    DWORD PTR [eax],edx
   0x0804851a <+82>:	cmp    DWORD PTR [ebp-0x8],0x10
   0x0804851e <+86>:	jne    0x804852b <check+99>
   ...
   ...
   0x08048526 <+94>:	call   0x8048484 <parell>


parell

   0x080484a4 <+32>:	mov    eax,DWORD PTR [ebp-0x4]
   0x080484a7 <+35>:	and    eax,0x1
   0x080484aa <+38>:	test   eax,eax
   0x080484ac <+40>:	jne    0x80484c6 <parell+66>


 
所以我们只需要满足：check中[ebp-0x8] = 0x10

parell中 eax最低位为偶数即可




➜  challenges ./crackme0x05
IOLI Crackme Level 0x05
Password: 972
Password OK!
➜  challenges ./crackme0x05
IOLI Crackme Level 0x05
Password: 5562
Password OK!

    

---

## crackme0x06 



